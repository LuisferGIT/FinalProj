split(mtcars,mtcars$cyl)
tapply(mtcars$hp, mtcars$cyl, mean)
debug(ls)
ls
makeVector <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setmean <- function(mean) m <<- mean
getmean <- function() m
list(set = set, get = get,
setmean = setmean,
getmean = getmean)
}
makeVector <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setmean <- function(mean) m <<- mean
getmean <- function() m
list(set = set, get = get,
setmean = setmean,
getmean = getmean)
}
datos <-c(1:20)
makeVector(datos)
makeVector(datos)
m
x
datos
c
cachemean <- function(x, ...) {
m <- x$getmean()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- mean(data, ...)
x$setmean(m)
m
}
cachemean(datos)
datos <- list(datos, 1:3, 1,09)
datos
datos <- list(datos, 1:3, 1.09)
datos
datos <- list(1:10, 1:3, 1.09)
datos
cachemean(datos)
datos <- c(1:10)
datos
makeVector(datos)
cachemean(datos)
cachemean(makeVector(datos))
mean(datos)
datos <-seq(1,10,length=22)
datos
mean(datos)
datos <-seq(1,20,length=22)
datos
mean(datos)
datos<- c(datos,26,12,13,38)
datos
mean(datos)
str(datos)
str(datos)
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinverse <- function(solve) m <<- solve
getsolve <- function() m
list(set = set, get = get,
setsolve = setsolve,
getsolve = getsolve)
}
matriz1<-matrix(1:4,2,2)
matriz1
makeCacheMatrix(matriz1)
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setsolve <- function(solve) m <<- solve
getsolve <- function() m
list(set = set, get = get,
setsolve = setsolve,
getsolve = getsolve)
}
matriz1<-matrix(1:4,2,2)
makeCacheMatrix(matriz1)
matriz1
inversamatriz1<-solve(matriz1)
inversamatriz1
inversamatriz1<-solve(inversamatriz1)
inversamatriz1
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getsolve()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x
m <- solve(data, ...)
x$setsolve(m)
m
}
cacheSolve(makeCacheMatrix(matriz1))
traceback()
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getsolve()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x
m <- solve(data)
x$setsolve(m)
m
}
cacheSolve(makeCacheMatrix(matriz1))
traceback()
3
2
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getsolve()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get
m <- solve(data)
x$setsolve(m)
m
}
cacheSolve(makeCacheMatrix(matriz1))
matriz1
cacheSolve(makeCacheMatrix(matriz1))
cacheSolve(makeCacheMatrix(matriz1))
matriz1
solve(matriz1)
cacheSolve(makeCacheMatrix(matriz1))
as.matrix(matriz1)
matriz1 <-matrix(rep(1,9),3,3)
matriz1
solve(matriz1)
matriz1 <-matrix(rep(1:3,3),3,3)
matriz1
solve(matriz1)
matriz1 <-matrix(rep(1,4,2,3,6,5,3,7,9,3,3)
matriz1
matriz1 <-matrix(1,4,2,3,6,5,3,7,9,3,3)
matriz1 <-matrix(c(1,4,2,3,6,5,3,7,9),3,3)
matriz1
solve(matriz1)
matriz1<-solve(matriz1)
matriz1
matriz1<-solve(matriz1)
matriz1
cacheSolve(makeCacheMatrix(matriz1))
debug(cachesolve)
debug(cacheSolve)
cacheSolve(makeCacheMatrix(matriz1))
View(x)
cacheSolve(makeCacheMatrix(matriz1))
cacheSolve(makeCacheMatrix(matriz1))
cacheSolve(makeCacheMatrix(matriz1))
cacheSolve(makeCacheMatrix(matriz1))
makeCacheMatrix(matriz1)
m1 <-makeCacheMatrix(matriz1)
cacheSolve(m1)
m1 <-makeCacheMatrix(matriz1)
m1
m1
m1 <-makeCacheMatrix(matriz1)
makeCacheMatrix <- function(x = matrix()) {
i <- NULL
set <- function(y) {
x <<- y
i <<- NULL
}
get <- function() x
setinverse <- function(inverse) i <<- inverse
getinverse <- function() i
list(set = set,
get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
i <- x$getinverse()
if (!is.null(i)) {
message("getting cached data")
return(i)
}
data <- x$get()
i <- solve(data, ...)
x$setinverse(i)
i
}
matriz1
m1 <-makeCacheMatrix(matriz1)
cacheSolve(m1)
cacheSolve(m1)
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() x
setinverse <- function(inverse) inv <<- inverse
getinverse <- function() inv
list(set = set,
get = get,
setinverse = setinverse,
getinverse = getinverse)
}
matriz1
m1 <-makeCacheMatrix(matriz1)
cacheSolve(m1)
cacheSolve(m1)
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inv <- x$getinverse()
if (!is.null(inv)) {
message("getting cached data")
return(inv)
}
data <- x$get()
inv <- solve(data, ...)
x$setinverse(inv)
inv
}
cacheSolve(m1)
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
## This function is based on the example, just creates a special "vector"
## which is really a list containing a function to
## set the value of the vector
## get the value of the vector
## set the value of the inverse
## get the value of the inverse
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() x
setinverse <- function(inverse) inv <<- inverse
getinverse <- function() inv
list(set = set,
get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## Write a short comment describing this function
## calculates the inverse of the special "vector" created with the above function.
## However, it first checks to see if the inverse has already been calculated.
## If so, it gets the inverse from the cache and skips the computation. Otherwise,
## it calculates the inverse of the data and sets the value of the inverse in the cache
## via the setinverse function.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inv <- x$getinverse()
if (!is.null(inv)) {
message("getting cached data")
return(inv)
}
data <- x$get()
inv <- solve(data, ...)
x$setinverse(inv)
inv
}
matriz1
m1 <-makeCacheMatrix(matriz1)
cacheSolve(m1)
cacheSolve(m1)
cacheSolve(m1)
inv
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
## This function is based on the example, just creates a special "vector"
## which is really a list containing a function to
## set the value of the vector
## get the value of the vector
## set the value of the inverse
## get the value of the inverse
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() x
setinverse <- function(inverse) inv <<- inverse
getinverse <- function() inv
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## Write a short comment describing this function
## calculates the inverse of the special "vector" created with the above function.
## However, it first checks to see if the inverse has already been calculated.
## If so, it gets the inverse from the cache and skips the computation. Otherwise,
## it calculates the inverse of the data and sets the value of the inverse in the cache
## via the setinverse function.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inv <- x$getinverse()
if (!is.null(inv)) {
message("getting cached data")
return(inv)
}
data <- x$get()
inv <- solve(data, ...)
x$setinverse(inv)
inv
}
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
## This function is based on the example Caching the Mean of a Vector,
## just creates a special "vector"
## which is really a list containing a function to
## set the value of the vector
## get the value of the vector
## set the value of the inverse
## get the value of the inverse
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() x
setinverse <- function(inverse) inv <<- inverse
getinverse <- function() inv
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## Write a short comment describing this function
## calculates the inverse of the special "vector" created with the above function.
## However, it first checks to see if the inverse has already been calculated.
## If so, it gets the inverse from the cache and skips the computation. Otherwise,
## it calculates the inverse of the data and sets the value of the inverse in the cache
## via the setinverse function.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inv <- x$getinverse()
if (!is.null(inv)) {
message("getting cached data")
return(inv)
}
data <- x$get()
inv <- solve(data, ...)
x$setinverse(inv)
inv
}
rnorm(5)
sample(1:43, 5)
baloto<- c(sample(1:43, 5), sample(1:16,1)
baloto
baloto<- c(sample(1:43, 5), sample(1:16,1))
baloto
baloto
baloto <-function(){}
baloto <-function(){c(sample(1:43,5),sample(1:16,1))}
baloto
str(baloto)
baloto <-function(){c(sample(1:43,5),sample(1:16,1))}
baloto()
baloto()
baloto()
baloto()
baloto()
baloto()
baloto()
baloto <-function(){c(sample(1:43,5),sample(1:16,1))}
baloto <-function(){c(sample(1:43,5),sample(1:16,1))}
baloto()
baloto()
baloto()
baloto()
baloto()
baloto()
baloto()
balotomatriz<-matrix(repe(baloto(),10)10,6)
balotomatriz<-matrix(cbind(repe(baloto(),10)))
balotomatriz<-matrix(cbind(repeat(baloto(),10)))
##Set work directory
setwd("D:/Coursera/Especializacion en Data Science/Curso 3 Getting and Cleaning Data/Semana 4 Subsetting and sorting/FinalProj")
##load package dplyr
library(dplyr)
##Download data from URL
filename <- "Data_UCI_Smartphones.zip"
# Verify if file exists in directory.
if (!file.exists(filename))
{
fileURL <- "https://d396qusza40orc.cloudfront.net/getdata%2Fprojectfiles%2FUCI%20HAR%20Dataset.zip"
download.file(fileURL, filename, method="curl")
}
# Unzip file create directory UCI HAR Dataset, this verify if directory exists
if (!file.exists("UCI HAR Dataset"))
{
unzip(filename)
}
features <- read.table("UCI HAR Dataset/features.txt", col.names = c("n","functions"))
features
##Set work directory
setwd("D:/Coursera/Especializacion en Data Science/Curso 3 Getting and Cleaning Data/Semana 4 Subsetting and sorting/FinalProj")
##load package dplyr
library(dplyr)
##Download data from URL
filename <- "Data_UCI_Smartphones.zip"
# Verify if file exists in directory.
if (!file.exists(filename))
{
fileURL <- "https://d396qusza40orc.cloudfront.net/getdata%2Fprojectfiles%2FUCI%20HAR%20Dataset.zip"
download.file(fileURL, filename, method="curl")
}
# Unzip file create directory UCI HAR Dataset, this verify if directory exists
if (!file.exists("UCI HAR Dataset"))
{
unzip(filename)
}
## Read the data frames and store in variables
features <- read.table("UCI HAR Dataset/features.txt", col.names = c("n","functions"))
activity_labels <- read.table("UCI HAR Dataset/activity_labels.txt", col.names = c("code", "activity"))
subject_test <- read.table("UCI HAR Dataset/test/subject_test.txt", col.names = "subject")
x_test <- read.table("UCI HAR Dataset/test/X_test.txt", col.names = features$functions)
y_test <- read.table("UCI HAR Dataset/test/y_test.txt", col.names = "code")
subject_train <- read.table("UCI HAR Dataset/train/subject_train.txt", col.names = "subject")
x_train <- read.table("UCI HAR Dataset/train/X_train.txt", col.names = features$functions)
y_train <- read.table("UCI HAR Dataset/train/y_train.txt", col.names = "code")
data_X <- rbind(x_train, x_test)
data_Y <- rbind(y_train, y_test)
Subject <- rbind(subject_train, subject_test)
Data_union <- cbind(Subject, data_Y, data_X)
## Step 2: Extracts only the measurements on the mean and standard deviation for each measurement.
TidyData <- Data_union %>% select(subject, code, contains("mean"), contains("std"))
View(TidyData)
## Step 2: Extracts only the measurements on the mean and standard deviation for each measurement.
TidyData <- Data_union %>% select(subject, code, contains("mean"), contains("std"))
view(data_X)
View(data_X)
View(x_train)
## Step 3: Uses descriptive activity names to name the activities in the data set.
TidyData$code <- activities[TidyData$code, 2]
## Step 3: Uses descriptive activity names to name the activities in the data set.
TidyData$code <- activity[TidyData$code, 2]
## Step 3: Uses descriptive activity names to name the activities in the data set.
TidyData$code <- activity_labels[TidyData$code, 2]
names(TidyData)[2] = "activity"
names(TidyData)<-gsub("Acc", "Accelerometer", names(TidyData))
names(TidyData)[2] = "activity"
names(TidyData)<-gsub("Acc", "Accelerometer", names(TidyData))
names(TidyData)<-gsub("Gyro", "Gyroscope", names(TidyData))
names(TidyData)<-gsub("BodyBody", "Body", names(TidyData))
names(TidyData)<-gsub("Mag", "Magnitude", names(TidyData))
names(TidyData)<-gsub("^t", "Time", names(TidyData))
names(TidyData)<-gsub("^f", "Frequency", names(TidyData))
names(TidyData)<-gsub("tBody", "TimeBody", names(TidyData))
names(TidyData)<-gsub("-mean()", "Mean", names(TidyData), ignore.case = TRUE)
names(TidyData)<-gsub("-std()", "STD", names(TidyData), ignore.case = TRUE)
names(TidyData)<-gsub("-freq()", "Frequency", names(TidyData), ignore.case = TRUE)
names(TidyData)<-gsub("angle", "Angle", names(TidyData))
names(TidyData)<-gsub("gravity", "Gravity", names(TidyData))
View(TidyData)
## Step 4: Appropriately labels the data set with descriptive variable names.
names(TidyData)[2] = "activity"
names(TidyData)<-gsub("accelerometer", "Accelerometer", names(TidyData))
names(TidyData)<-gsub("gyroscope", "Gyroscope", names(TidyData))
names(TidyData)<-gsub("body", "Body", names(TidyData))
names(TidyData)<-gsub("magnitude", "Magnitude", names(TidyData))
names(TidyData)<-gsub("time", "Time", names(TidyData))
names(TidyData)<-gsub("frequency", "Frequency", names(TidyData))
names(TidyData)<-gsub("timeBody", "TimeBody", names(TidyData))
names(TidyData)<-gsub("-mean()", "Mean", names(TidyData), ignore.case = TRUE)
names(TidyData)<-gsub("-std()", "STD", names(TidyData), ignore.case = TRUE)
names(TidyData)<-gsub("-freq()", "Frequency", names(TidyData), ignore.case = TRUE)
names(TidyData)<-gsub("angle", "Angle", names(TidyData))
names(TidyData)<-gsub("gravity", "Gravity", names(TidyData))
## Step 5: From the data set in step 4, creates a second, independent tidy data set with the average of each variable for each activity and each subject.
FinalData <- TidyData %>%
group_by(subject, activity) %>%
summarise_all(funs(mean))
write.table(FinalData, "FinalData.txt", row.name=FALSE)
str(FinalData)
FinalData
